{
  "_args": [
    [
      {
        "raw": "@nx-js/observer-util@^2.0.0",
        "scope": "@nx-js",
        "escapedName": "@nx-js%2fobserver-util",
        "name": "@nx-js/observer-util",
        "rawSpec": "^2.0.0",
        "spec": ">=2.0.0 <3.0.0",
        "type": "range"
      },
      "G:\\school_rankings_development\\node_modules\\@nx-js\\framework"
    ]
  ],
  "_from": "@nx-js/observer-util@>=2.0.0 <3.0.0",
  "_id": "@nx-js/observer-util@2.0.0",
  "_inCache": true,
  "_location": "/@nx-js/observer-util",
  "_nodeVersion": "6.2.0",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/observer-util-2.0.0.tgz_1486489258551_0.2146657989360392"
  },
  "_npmUser": {
    "name": "nx-js",
    "email": "miklos.bertalan@risingstack.com"
  },
  "_npmVersion": "3.8.9",
  "_phantomChildren": {},
  "_requested": {
    "raw": "@nx-js/observer-util@^2.0.0",
    "scope": "@nx-js",
    "escapedName": "@nx-js%2fobserver-util",
    "name": "@nx-js/observer-util",
    "rawSpec": "^2.0.0",
    "spec": ">=2.0.0 <3.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/@nx-js/framework",
    "/@nx-js/observe-middleware"
  ],
  "_resolved": "https://registry.npmjs.org/@nx-js/observer-util/-/observer-util-2.0.0.tgz",
  "_shasum": "f85a1379100dbec8a289ded901be5ddc27c8aac7",
  "_shrinkwrap": null,
  "_spec": "@nx-js/observer-util@^2.0.0",
  "_where": "G:\\school_rankings_development\\node_modules\\@nx-js\\framework",
  "author": {
    "name": "Miklos Bertalan",
    "email": "miklos.bertalan@risingstack.com"
  },
  "bugs": {
    "url": "https://github.com/nx-js/observer-util/issues"
  },
  "dependencies": {},
  "description": "An NX utility, responsible for powerful data observation with ES6 Proxies.",
  "devDependencies": {
    "chai": "3.5.0",
    "mocha": "2.5.3",
    "pre-push": "0.1.1",
    "standard": "7.1.2"
  },
  "directories": {},
  "dist": {
    "shasum": "f85a1379100dbec8a289ded901be5ddc27c8aac7",
    "tarball": "https://registry.npmjs.org/@nx-js/observer-util/-/observer-util-2.0.0.tgz"
  },
  "engines": {
    "node": ">=6.0.0"
  },
  "gitHead": "c72187440eb8fdb457adf54ea948179681c1b8de",
  "homepage": "https://github.com/nx-js/observer-util#readme",
  "keywords": [
    "nx",
    "observe",
    "observable",
    "data",
    "binding",
    "proxy",
    "ES6",
    "reactive"
  ],
  "license": "MIT",
  "maintainers": [
    {
      "name": "nx-js",
      "email": "miklos.bertalan@risingstack.com"
    }
  ],
  "name": "@nx-js/observer-util",
  "optionalDependencies": {},
  "pre-push": [
    "lint",
    "test"
  ],
  "readme": "# The observer utility\n\nThis library is part of the [NX framework](http://nx-framework.com).\n\nThe purpose of this library is to provide transparent reactivity without any special syntax and with a 100% language observability coverage.\nIt uses ES6 Proxies internally to work seamlessly with a minimal interface.\nA blog post about the inner working of this library can be found\n[here](https://blog.risingstack.com/writing-a-javascript-framework-data-binding-es6-proxy/) and a comparison with MobX can be found [here](http://www.nx-framework.com/blog/public/mobx-vs-nx/).\n\n## Installation\n\n```\n$ npm install @nx-js/observer-util\n```\n\n## Platform support\n\n- Node: 6 and above\n- Chrome: 49 and above (after browserified)\n- Firefox: 38 and above (after browserified)\n- Safari: 10 and above (after browserified)\n- Edge: 12 and above (after browserified)\n- Opera: 36 and above (after browserified)\n- IE is not supported\n\n## Usage\n\n```js\nconst observer = require('@nx-js/observer-util')\n```\n\n## API\n\n### observer.observable([Object])\n\nThis method creates and returns an observable object. If an object is passed as argument\nit wraps the passed object in an observable. If an observable object is passed, it simply\nreturns the passed observable object.\n\n```js\nconst observable = observer.observable({prop: 'someValue'})\n```\n\n### observer.isObservable(Object)\n\nReturns true if the passed object is an observable, otherwise returns false.\n\n```js\nconst observable = observer.observable()\nconst isObservable = observer.isObservable(observable)\n```\n\n### const signal = observer.observe(function, [context], ...[args])\n\nThis method observes the passed function. An observed function automatically reruns when a property of an observable - which is used by the function - changes (or is deleted). The function doesn't run immediately on property change, instead it runs after a small delay (when the current stack empties).\nMultiple synchronous changes won't cause the function to run multiple times. Changes that result in no value change - like `state.prop = state.prop` - won't cause the function to run either.\nThe function can observe any synchronous javascript code (nested data, iterations, function calls, getters/setters, etc.)\n\nA `this` context and a list of argument can be passed after the observed function as arguments. In this case the observed function will always be called with the passed `this` context and arguments.\n\n```js\nobserver.observe(printSum, context, arg1, arg2)\n\nfunction printSum (arg1, arg2) {\n  console.log(arg1 + arg2)\n}\n```\n\n`observe()` returns a signal object, which can be used to stop or modify the observation.\n\n```js\nconst signal = observer.observe(() => console.log(observable.prop))\n```\n\n### signal.unobserve()\n\nCalling `signal.unobserve()` unobserves the observed function associated with the passed signal. Unobserved functions won't be rerun by observable changes anymore.\n\n```js\nconst signal = observer.observe(() => console.log(observable.prop))\nsignal.unobserve()\n```\n\n### signal.unqueue()\n\nCalling `signal.unqueue()` removes the observed function from the set of triggered and queued observed functions, but it doesn't unobserve it. It can still be triggered and requeued by later observable changes.\n\n```js\nconst signal = observer.observe(() => console.log(observable.prop))\nsignal.unqueue()\n```\n\n### signal.exec()\n\nRuns the observed function. Never run an observed function directly, use this method instead!\n\n```js\nconst signal = observer.observe(() => console.log(observable.prop))\nsignal.exec()\n```\n\n## Example\n\n```js\nconst observer = require('@nx-js/observer-util')\n\n// creating two observable objects\nconst observable1 = observer.observable({num: 0})\nconst observable2 = observer.observable({num: 0})\n\n// outputs 0 to the console\n// the passed parameters are: observed func, injected 'this' context, injected arguments\nconst signal = observer.observe(printSum, undefined, observable1, observable2)\n\nfunction printSum (obj1, obj2) {\n  console.log(obj1.num + obj2.num)\n}\n\n// outputs 2 to the console\nsetTimeout(() => observable1.num = 2, 100)\n\n// outputs 7 to the console\nsetTimeout(() => observable2.num = 5, 200)\n\n// finishes observing\nsetTimeout(() => signal.unobserve(), 300)\n\n// observation is finished, doesn't trigger printSum, outputs nothing to the console\nsetTimeout(() => observable1.num = 6, 400)\n```\n\n## Features and edge cases\n\n#### observable argument cases\n\nIf an observable is passed as argument to the observer.observable method, it simply returns the passed observable. If you pass the same object into different observer.observable calls, it always returns the same observable instance.\n\n```js\nconst observer = require('@nx-js/observer-util')\n\nconst obj = {prop: 'value'}\nconst observable1 = observer.observable(obj)\nconst observable2 = observer.observable(obj)\nconst observable3 = observer.observable(observable1)\n\n// these output 'true' to the console\nconsole.log(observable1 === observable2)\nconsole.log(observable2 === observable3)\n```\n\n#### when does the observed function run\n\nEvery observed function runs once synchronously when it is passed to `observer.observe`.\n\nAfter that an observed function runs after every stack in which the observable properties used by it changed value. It runs maximum once per stack and multiple synchronous changes of the observable properties won't trigger it more than once. Setting on observable property without a value change won't trigger it either.\n\n```js\nconst observer = require('@nx-js/observer-util')\n\nconst observable = observer.observable({prop: 'value'})\n\n// outputs 'value' to the console synchronously\nobserver.observe(() => console.log(observable.prop))\n\n// causes only 1 rerun, outputs 'newer value' to the console\nsetTimeout(() => {\n  observable.prop = 'new value'\n  observable.prop = 'newer value'\n})\n\n// causes no rerun (the value did not change), doesn't trigger console.log\nsetTimeout(() => observable.prop = 'newer value', 100)\n```\n\n#### observing expando properties\n\nExpando (dynamically added) properties can be observed without any special syntax.\n\n```js\nconst observer = require('@nx-js/observer-util')\n\nconst observable = observer.observable()\n\n// outputs 'undefined' to the console\nobserver.observe(() => console.log(observable.expando))\n\n// outputs 'dynamically added prop' to the console\nsetTimeout(() => observable.expando = 'dynamically added prop', 100)\n```\n\n#### observing conditionals\n\nAny synchronous JavaScript code can be observed. This includes code 'hidden behind' conditionals or loops.\n\n```js\nconst observer = require('@nx-js/observer-util')\n\nconst observable = observer.observable({\n  condition: true,\n  prop1: 'prop1',\n  prop2: 'hidden'\n})\n\n// outputs 'prop1' to the console\nobserver.observe(() => console.log(observable.condition ? observable.prop1 : observable.prop2))\n\n// outputs 'hidden' to the console\nsetTimeout(() => observable.condition = false, 100)\n\n// outputs 'but tracked' to the console\nsetTimeout(() => observable.prop2 = 'but tracked', 200)\n```\n\n#### observing nested properties\n\nObserving nested properties works with arbitrary depth.\n\n```js\nconst observer = require('@nx-js/observer-util')\n\nconst observable = observer.observable({prop: {nested: 'nestedValue'}})\n\n// outputs 'nestedValue' to the console\nobserver.observe(() => console.log(observable.prop.nested))\n\n// outputs 'otherValue' to the console\nsetTimeout(() => observable.prop.nested = 'otherValue', 100)\n```\n\n#### observing implicit properties\n\nThe library also observes implicit properties. Implicit properties are not directly used\nby your code, but by native function implementations for example.\n\n```js\nconst observer = require('@nx-js/observer-util')\n\nconst observable = observer.observable({words: ['Hello', 'World']})\n\n// outputs 'Hello World' to the console\nobserver.observe(() => console.log(observable.words.join(' ')))\n\n// outputs 'Hello World !' to the console\nsetTimeout(() => observable.words.push('!'), 100)\n\n// outputs 'Hello There !' to the console\nsetTimeout(() => observable.words.splice(1, 1, 'There'), 200)\n```\n\n#### observing inherited properties\n\nYou can use prototypal inheritance with observables.\nThe library walks and observes the prototype chain correctly.\n\n```js\nconst observer = require('@nx-js/observer-util')\n\nconst parentObservable = observer.observable({greeting: 'Hello'})\nconst observable = observer.observable({subject: 'World!'})\n\nObject.setPrototypeOf(observable, parentObservable)\n\n// outputs 'Hello World' to the console\nobserver.observe(() => console.log(observable.greeting + ' ' + observable.subject))\n\n// outputs 'Hello There!' to the console\nsetTimeout(() => observable.subject = 'There!')\n\n// outputs 'Hey There!' to the console\nsetTimeout(() => parentObservable.greeting = 'Hey', 100)\n\n// outputs 'Look There!' to the console\nsetTimeout(() => observable.greeting = 'Look', 200)\n\n// outputs 'Hey There!' to the console\nsetTimeout(() => delete observable.greeting, 300)\n```\n\n#### observing getters/setters\n\nComputed getters/setter properties of observables will be correctly observed by observer functions.\n\n```js\nconst observer = require('@nx-js/observer-util')\n\nconst observable = observer.observable({\n  num1: 0,\n  num2: 0,\n  get sum () { return this.num1 + this.num2 },\n  set sum (value) {\n    this.num1 = value / 2\n    this.num2 = value / 2\n  }\n})\n\n// outputs 0  to the console\nobserver.observe(() => console.log(observable.sum))\n\n// outputs 1 to the console\nsetTimeout(() => observable.num1 = 1)\n\n// outputs 4 to the console\nsetTimeout(() => observable.num2 = 3, 100)\n\n// changes num1 and num2 to 3, outputs 6 the console\nsetTimeout(() => observable.sum = 6, 200)\n```\n\n#### two way binding\n\nEvery observed function is guaranteed to run maximum once per stack.\nAsynchronous infinite loops are also handled and avoided by the library.\n\n```js\nconst observer = require('@nx-js/observer-util')\n\nconst observable1 = observer.observable({prop: 'value1'})\nconst observable2 = observer.observable({prop: 'value2'})\n\nobserver.observe(() => observable1.prop = observable2.prop)\nobserver.observe(() => observable2.prop = observable1.prop)\n\nsetTimeout(() => observable1.prop = 'Hello')\n// outputs 'Hello' to the console\nsetTimeout(() => console.log(observable2.prop), 100)\n\nsetTimeout(() => observable2.prop = 'World', 200)\n// outputs 'World' to the console\nsetTimeout(() => console.log(observable1.prop), 300)\n```\n\n#### selective observation\n\nSometimes you might want a certain set operation to not trigger observers, or a certain\nobservable property to not be observed by the observer function. In this case you should\nuse `observable.$raw`, which is the exposed raw (unwrapped) object behind the observable.\nThis object will not cause any observers to be triggered or registered.\n\n```js\nconst observer = require('@nx-js/observer-util')\n\nconst person = observer.observable({\n  name: 'John',\n  age: 25\n})\n\n// outputs 'name: John, age: 25' to the console\nobserver.observe(() => console.log(`name: ${person.name}, age: ${person.$raw.age}`))\n\n// will not cause a rerun, since the observer only uses person.$raw.age\n// outputs nothing to the console\nsetTimeout(() => person.age = 30)\n\n// outputs 'name: Bill, age: 30' to the console\nsetTimeout(() => person.name = 'Bill', 100)\n\n// will not cause a rerun, since it only modifies person.$raw\n// outputs nothing to the console\nsetTimeout(() => person.$raw.name = 'Anne', 200)\n```\n\n## Performance\n\nThis [benchmark](/benchmark/benchmark.js) compares vanilla JS, [MobX](http://mobxjs.github.io) and nx-observe\nin a few scenarios. You can set it up locally with the `npm run build-benchmark-mac` or\n`npm run build-benchmark-ubuntu` command (depending on your OS) and run it\nwith `npm run benchmark`. The result on a MacBook Pro with Node 6.2.0 can be seen below.\n\n![Benchmark result](/benchmark/benchmark.png)\n\n- The first two tests compare NX and MobX observable creation cost with plain JS object creation.\n\n- 'New property' tests the cost of adding expando properties to a plain object or an observable without any observer function. MobX requires the special `mobx.extendObservable(obj, { prop: 'value' })` syntax instead of `obj.prop = 'value'`.\n\n- 'Get and set operation' tests the cost of get/set operations of a plain object or an observable without any observer function.\n\n- 'Function creation' tests the cost of vanilla JS function creation versus `mobx.autorun(newFn)` and `nx.observe(newFn)`.\n\n- 'Function trigger' tests the cost of intercepting observable property mutations and running the appropriate reactions. The 'no value change' test checks the same thing, in case of observable property mutations without a value change.\n\n- 'Function cleanup' tests the cost of disposing observer/listener functions with `disposeFn()` or `signal.unobserve()`.\n\nDo not worry about the large difference between the vanilla and nx-observe / MobX results.\nThe operations tested above are some of the fastest ones in vanilla JS. The overhead would be a\nlot smaller compared to some commonly used built in objects, like Promises.\n\n## Contributions\n\nThis library has the very specific purpose of supporting the\n[NX framework](https://github.com/nx-js/framework).\nFeatures should only be added, if they are used by the framework. Otherwise please fork.\n\nBug fixes, tests, benchmark corrections and doc updates are always welcome.\nTests and linter (standardJS) must pass.\n\n## Authors\n\n  - [Miklos Bertalan](https://github.com/solkimicreb)\n\n# License\n\n  MIT\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/nx-js/observer-util.git"
  },
  "scripts": {
    "benchmark": "node benchmark/benchmark",
    "build-benchmark-mac": "brew install pkg-config cairo pango libpng jpeg giflib && npm i canvas nchart mobx",
    "build-benchmark-ubuntu": "sudo apt-get install libcairo2-dev libjpeg8-dev libpango1.0-dev libgif-dev build-essential g++ && npm i canvas nchart mobx",
    "lint": "standard",
    "test": "mocha test"
  },
  "standard": {
    "ignore": [
      "test",
      "benchmark"
    ],
    "globals": [
      "MutationObserver"
    ]
  },
  "version": "2.0.0"
}
